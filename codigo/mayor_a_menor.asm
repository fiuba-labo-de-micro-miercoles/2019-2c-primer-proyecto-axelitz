.include "m328pdef.inc"

.DEF REG_VACIO = R15
.DEF CANT_NROS = R16
.DEF CANT_NROS_A_COMPARAR = R17
.DEF SIG_POS_LECTURA_H = R18
.DEF SIG_POS_LECTURA_L = R19
.DEF MAX_A_COMPARAR = R20
.DEF POSIBLE_MAX = R21
.DEF POS_A_LLENAR_H = R22
.DEF POS_A_LLENAR_L = R23
.DEF TEMP = R24

.EQU cant_nros_tabla = 6;CANTIDAD DE NUMEROS EN LA TABLA PARA ORDENAR

TABLA:.DB 0x01,0x05,0x06,0x08,0x02,0x07;TABLA DE NUMEROS A LLENAR

.CSEG
	RJMP MAIN

.ORG INT_VECTORS_SIZE

MAIN:
;INICIALIZO STACK
	LDI TEMP,HIGH(RAMEND)
	OUT SPH,TEMP
	LDI TEMP,LOW(RAMEND)
	OUT SPL,TEMP
;[FIN]INICIALIZO STACK

	RCALL ORDENAR
	RCALL GUARDAR

HERE: RJMP HERE

ORDENAR:
	LDI ZH,HIGH(TABLA<<1);CARGO A PUNTERO Z CON DIRECCION DE MEMORIA DE LA TABLA
	LDI ZL,LOW(TABLA<<1);CARGO A PUNTERO Z CON DIRECCION DE MEMORIA DE LA TABLA
	LDI CANT_NROS,cant_nros_tabla;GUARDO EN R16 LA CANTIDAD DE NUMEROS A ORDENAR
	LDI CANT_NROS_A_COMPARAR,cant_nros_tabla-1;GUARDO EN R17 LA CANTIDAD DE NUMEROS A COMPARAR CON LA POSICION A LLENAR
	LPM MAX_A_COMPARAR,Z+;GUARDO EN R20 EL NUMERO A COMPARAR CON EL RESTO
	LDI POS_A_LLENAR_H,HIGH(TABLA<<1);GUARDO EN R22 EL BYTE SUPERIOR DE LA POSICION A LLENAR
	LDI POS_A_LLENAR_L,LOW(TABLA<<1);GUARDO EN R23 EL BYTE INFERIOR DE LA POSICION A LLENAR

COMPARAR:
	LPM POSIBLE_MAX,Z+;GUARDO EN R21 EL NUMERO TEMPORARIO A COMPARAR CON EL ACTUAL (QUE ESTA EN R20)
	CP MAX_A_COMPARAR,POSIBLE_MAX;COMPARO EL SUPUESTO MAYOR NUMERO (R20) CON EL POSIBLE MAYOR NUMERO (R21)
	BRLO INTERCAMBIAR;SI EL NUMERO SUPUESTAMENTE MAYOR (R20) ES MENOR QUE EL OTRO (R21), SE PROCEDE A CAMBIAR EL NUMERO A COMPARAR
CONTINUAR_COMPARACION:
	DEC CANT_NROS_A_COMPARAR;BAJO EN 1 LOS NUMEROS A COMPARAR CON EL ACTUAL
	CPI CANT_NROS_A_COMPARAR,0;REVISO SI TENGO NUMERO PARA COMPARAR CON EL ACTUAL
	BREQ AVANZAR_POSICION;SI YA ME QUEDE SIN NUMEROS EN LA TABLA PARA COMPARAR, PROCEDO A LLENAR LA SIGUIENTE POSICION
	RJMP COMPARAR;VUELVO A COMENZAR EL PROCESO DE COMPARACION

INTERCAMBIAR:
	ST -Z,MAX_A_COMPARAR;CARGO EN ESTA POSICION DE LA TABLA EL ANTERIOR NUMERO MAYOR
	MOV SIG_POS_LECTURA_H,ZH;GUARDO EN R18 EL BYTE SUPERIOR DE LA POSICION EN LA TABLA EN LA QUE TENGO QUE SEGUIR LEYENDO
	MOV SIG_POS_LECTURA_L,ZL;GUARDO EN R19 EL BYTE INFERIOR DE LA POSICION EN LA TABLA EN LA QUE TENGO QUE SEGUIR LEYENDO
	INC SIG_POS_LECTURA_L;PARA LEER LA SIGUIENTE POSICION A LA LEIDA PARA ENTRAR ACA
	MOV ZH,POS_A_LLENAR_H;CARGO EN EL BYTE SUPERIOR DE Z (GUARDADO EN R22) LA POSICION DONDE TENGO QUE REEMPLAZAR AL NUEVO NUMERO MAYOR
	MOV ZL,POS_A_LLENAR_L;CARGO EN EL BYTE INFERIOR DE Z (GUARDADO EN R23) LA POSICION DONDE TENGO QUE REEMPLAZAR AL NUEVO NUMERO MAYOR
	ST Z,POSIBLE_MAX;GUARDO EN LA POSICION DE LA TABLA CORRESPONDIENTE EL NUEVO NUMERO MAYOR PARA ESTA POSICION
	MOV MAX_A_COMPARAR,POSIBLE_MAX;GUARDO EL NUEVO NUEVO MAYOR A COMPARAR EN R20
	MOV ZH,SIG_POS_LECTURA_H;CARGO EN EL BYTE SUPERIOR DE Z LA POSICION PARA CONTINUAR LEYENDO
	MOV ZL,SIG_POS_LECTURA_L;CARGO EN EL BYTE INFERIOR DE Z LA POSICION PARA CONTINUAR LEYENDO
	RJMP CONTINUAR_COMPARACION

AVANZAR_POSICION:
	INC POS_A_LLENAR_L;AUMENTO EN UNO LA POSICION DE LA TABLA DONDE HAY QUE CONTINUAR LEYENDO (R23 = BYTE INFERIOR)
	CLR REG_VACIO;LIMPIO EL REGISTRO R15 PARA TENER UN VALOR EN 0
	ADC POS_A_LLENAR_H,REG_VACIO;SI R23 = FF, ENTONCES TENGO EN UNO EL CARRY Y DEBO SUMARLE UNO AL BYTE SUPERIOR EN R22
	MOV ZH,POS_A_LLENAR_H;CARGO EN Z LA POSICION PARA SEGUIR LEYENDO (BYTE SUPERIOR)
	MOV ZL,POS_A_LLENAR_L;CARGO EN Z LA POSICION PARA SEGUIR LEYENDO (BYTE INFERIOR)
	LPM MAX_A_COMPARAR,Z+;GUARDO EN R20 EL NUMERO A COMPARAR CON EL RESTO
	DEC CANT_NROS;BAJO EN UNO LA CANTIDAD DE NUMEROS DE LA TABLA QUE ME QUEDAN LLENAR
	MOV CANT_NROS_A_COMPARAR,CANT_NROS;ACTUALIZO LA CANTIDAD DE NUMEROS A COMPARAR CON LA POSICION ACTUAL
	DEC CANT_NROS_A_COMPARAR;BAJO EN UNO LA CANTIDAD DE NUMEROS A COMPARAR YA QUE DEBO COMPARAR LOS QUE QUEDAN CON EL FIJO
	BRNE COMPARAR;SI TENGO NUMEROS PARA COMPARAR, VUELVO A LA ETIQUETA QUE ME PERMITE HACERLO
RET;SI NO ME QUEDAN NUMEROS PARA COMPARAR, DOY POR FINALIZADO LA TAREA DE ORDENAMIENTO DE LA TABLA

GUARDAR:
	LDI ZH,HIGH(TABLA<<1);CARGO A PUNTERO Z CON DIRECCION DE INICIO DE LA TABLA (BYTE SUPERIOR)
	LDI ZL,LOW(TABLA<<1);CARGO A PUNTERO Z CON DIRECCION DE INICIO DE LA TABLA (BYTE INFERIOR)
	;0x0300 = POSICION DE MEMORIA DONDE QUIERO GUARDAR LA TABLA
	LDI XH,HIGH(0x0300<<1);CARGO A PUNTERO X CON DIRECCION DE INICIO DE LA TABLA A LLENAR (BYTE SUPERIOR)
	LDI XL,LOW(0x0300<<1);CARGO A PUNTERO X CON DIRECCION DE INICIO DE LA TABLA A LLENAR (BYTE INFERIOR)
	LDI CANT_NROS,cant_nros_tabla;GUARDO EN R16 LA CANTIDAD DE NUMEROS A CARGAR PARA LLEVAR UN SEGUIMIENTO

LLENAR_SEGUNDA_TABLA:
	LPM TEMP,Z+;GUARDO EN EL REGISTRO R24 EL NUMERO ACTUAL A CARGAR EN LA NUEVA TABLA Y ME MUEVO UNA POSICION EN LA TABLA LLENA
	ST X+,TEMP;GUARDO EN EL REGISTRO R24 EL NUMERO ACTUAL EN LA NUEVA TABLA Y ME MUEVO UNA POSICION EN LA TABLA A LLENAR
	DEC CANT_NROS;BAJO EN UNO LA CANTIDAD DE NUMEROS A LLENAR
	BRNE LLENAR_SEGUNDA_TABLA;SI NO ES 0 LA CANTIDAD DE NUMEROS A LLENAR, CONTINUO CON EL PROCESO
RET;SI YA TERMINE DE PASAR TODOS LOS NUMEROS, DOY POR FINALIZADO EL PROCESO
